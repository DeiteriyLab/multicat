1. **Клиент** (Client): Запускает hashcat с необходимыми wordlists и правилами для обработки чанков хешей.
2. **Сервер** (Server): Распределяет нагрузку и хеши между клиентами, оптимизируя процесс в зависимости от мощности каждого клиента.
3. **Агент** (Agent): Телеграм-бот, управляющий процессами, принимает GPG файлы и расшифровывает их.

### Общий процесс:

1. **Агент** получает GPG файл от пользователя через Телеграм, расшифровывает его и извлекает хеши. Затем он отправляет хеши на **Сервер**.
2. **Сервер** анализирует полученные хеши, оценивает нагрузку и мощность подключенных **Клиентов**, и на основе этого оптимально распределяет хеши по чанкам.
3. **Сервер** отправляет чанки хешей на **Клиенты** вместе с необходимыми wordlists и правилами (определенными в YAML и валидируемыми через Pydantic).
4. **Клиенты** выполняют брут хешей с использованием hashcat и возвращают результаты на **Сервер**.

### Технологический стек:

- **Python**: Основной язык программирования.
- **YAML и Pydantic**: Для определения и валидации правил.
- **Celery**: Для асинхронной работы и распределения задач между **Клиентами**.
- **PostgreSQL (pgsql)**: Для хранения данных о хешах, клиентах, состоянии задач и результатов.

### Архитектурные компоненты:

1. **Агент (Телеграм-бот)**:
   - Разработан на `aiogram`.
   - Принимает и расшифровывает GPG файлы.
   - Передает хеши на сервер для дальнейшей обработки.

2. **Сервер**:
   - Управляет распределением задач с помощью `Celery`.
   - Анализирует мощность клиентов и нагрузку для оптимального распределения хешей.
   - Использует `PostgreSQL` для хранения информации о клиентах, задачах и результатах.
   - Отправляет задачи на клиенты и принимает результаты.

3. **Клиент**:
   - Получает чанки хешей и информацию для запуска hashcat.
   - Выполняет брут хешей и отправляет результаты обратно на сервер.

4. **Система контроля и управления задачами**:
   - Использует `Celery` для асинхронного выполнения задач и распределения нагрузки.
   - Позволяет масштабировать систему, добавляя дополнительных клиентов без необходимости изменения архитектуры.

### Процесс расчета чанка:
- Определение размера чанка основывается на кол-ве хешей (`Keyspace`) и производительности (`Performance`).
- Размер чанка = `Keyspace / Overall Performance`, где `Overall Performance` — это суммарная производительность всех клиентов.
